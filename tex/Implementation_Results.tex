\chapter{Implementation and Results}
\label{ch:implementation_results}

In this chapter, we describe the implementation of the algorithms that we have developed in \Cref{ch:heuristics} and \Cref{ch:optimal_approach}. All heuristical solution methods, based on the customer-dependent and time-dependent splitting and the iterative approach have been implemented and tested. Further, the optimal approach has been implemented and tested. The underlying test instances have been created as described in \Cref{ch:instance_creation}. Additionally, we provide computational results for all these algorithms and compare them with respect to computation time and results. Finally, we contextualize the results in the problem description as stated in \Cref{ch:problem_description}.

%----------------------------------------------------------------------------------------------------------------------------------------

\section{Implementation}
\label{sec:implementation}

Similar to the mathematical models, we adapt great parts of the implementation from the underlying theses \cite{Kaiser} and \cite{Knoll}. Concerning the heuristics, on the one hand we limit ourselves to only one approach of the heuristics developed by \cite{Knoll}. On the other hand, we heavily extend this approach into two different splitting methods and the iterative approach. In order to provide these methods and to keep the code clearly arranged, we modify the majority of the existing code for the heuristics. In contrast, the optimal approach developed by \cite{Kaiser} is quite similar. Thus, we reuse most of the code for the optimal approach and adjust it on a few positions. 

\paragraph{Implementation Details} \parfill

Before describing the implementation, we go into some details in the models and the algorithms that we have not yet been stated in detail or that we have slightly modified in the implementation.

For the heuristics, we need to determine the number of partial instances $n$ and the time points $c_i$, ${i\in[n-1]}$. An approach is to choose the time points iteratively, \enquote{such that a partial instance, that is as large as possible but still solvable to optimality in reasonable time, arises.} (\cite[p.~131]{Knoll}) We do not examine, how large the partial instances may be. Instead, we determine all time points in advance such that the number of vehicles and trip is the same in each partial instance.

As opposed to \Cref{ch:heuristics}, we do not consider all refuel points $r\in\Rst$ for some arc $(s,t)\in A$. Instead, we only consider one refuel point $r\in\Rst$ for which ${\cd_{s,r} + \cd_{r,t}}$ is minimal, provided that ${\Rst\neq\emptyset}$. This involves a strong simplification in implementing the heuristic, as the task graph contains only one arc with additional information. Further it reduces the computation time due to much fewer possibilities. In the optimal approach, we use a set of Pareto-optimal refuel points \wrt a suitable function. This approach is examined by \cite[Sec.~3.2.2]{Kaiser} and \cite[Sec.~3.2.2]{Knoll} and guarantees an optimal solution.

In the optimal approach, we model the cover constraints by using auxiliary variables $u_m$ for ${m\in\mathcal{M}}$:
\begin{align*}
	& \sum_{m\in C^{-1}(c)} u_m = 1 && \text{for all } c\in\mathcal{C} \tag{\ref{eq:MMILP:customer}} \\
	& \sum_{v\in\mathcal{V}} y^v_t = u_{M(t)} && \text{for all } t\in\mathcal{T} \tag{\ref{eq:MMILP:linking_y}}
\end{align*}

However, we can find an equivalent formulation without these auxiliary variables. For this, we define a function ${T:\mathcal{M}\to\mathcal{T}}$ with ${\left(T\circ M\right)(m)=m}$. This means, $T$ maps a route to a fixed trip of the route, \eg to its first trip. Then, we have ${u_m=1}$ if and only if trip $T(m)$ is fulfilled and an equivalent formulation of the cover constraints reads as:
\begin{align*}
	& \sum_{m\in C^{-1}(c)} \sum_{v\in\mathcal{V}} y^v_{T(m)} = 1 && \text{for all } c\in\mathcal{C} \\
	& \sum_{v\in\mathcal{V}} y^v_t = \sum_{v\in\mathcal{V}} y^v_{(M\circ T)(t)} && \text{for all } t\in\mathcal{T}\backslash\Cupdot_{m\in\mathcal{M}} T(m)
\end{align*}

Further, we use the auxiliary variables for stating the route cost in the objective function. We delete the term $\sum_{m\in\mathcal{M}} u_m\croute_m$ and modify the trip cost for the $T(m)$ instead. For an equivalent formulation, we use modified trip costs $\hat{c}^{\operatorname{t}}$ that are defined as
\begin{align*}
	\hat{c}^{\operatorname{t}}_t = \begin{cases} \ct_t + \croute_{M(t)} & \text{if } t = \left(M\circ T\right)(t) \\ \ct_t & \text{otherwise} \end{cases} && \text{for } t\in\mathcal{T}.
\end{align*}

We use the equivalent formulation with the modified cover constraints and the trip costs $\hat{c}^{\operatorname{t}}$ for implementing the optimal approach.

\paragraph{Instance Creation and General Procedure} \parfill

The procedure for creating the test instances and providing them to the heuristical and the optimal solver is implemented in Python 2.7. The instances are created based on a test instance with realistic trips, provided by \cite{Kaiser} and \cite{Knoll}.

The following main files are called by the user in order to create a test instance and to solve it. The file \texttt{data.py} provides the functionality to create a test instance for a given number of customers, vehicles and a maximal number of alternative routes per customer. It calls the OpenTripPlanner (OTP) via a HTTP-request in order to create the multimodal routes and the OpenSourceRoutingMachine (OSRM) in order to compute a distance and time matrix. The file \texttt{build.py} is called to build the task graph. For each pair of trips, the time feasibility is examined. If applicable, a refuel point is picked for this arc and the arc fuel and arc cost are computed. The procedure to run the heuristics is contained in the file \texttt{heuristic.py}. As arguments, it requires the number of vertices per partial instance and the kind of heuristic to execute. After splitting the instance, it iteratively creates a partial task graph, invokes the solver for the partial instance, reads the partial solution and creates the endpoints. Finally, it composes an overall solution. For the iterative approach, it iteratively determines the customers to review and invokes the solver. The file \texttt{optimal\_approach.py} is called to compute an optimal solution. It reads a feasible initial solution, computes the Pareto-optimal refuel points and calls the process for solving the instance to optimality.

The following auxiliary files contain the methods that are called by the main procedures. The file \texttt{otp.py} provides the methods to communicate with OTP. It opens the HTTP-connection and handles the requests. The file \texttt{osrm.py} opens the HTTP-connection to OSRM and creates the distance and time matrix for an instance. The file \texttt{instance.py} contains all information of a problem instance, \ie the sets $\mathcal{C}$, $\mathcal{M}$, $\mathcal{T}$, $\mathcal{V}$ and $\mathcal{R}$. It further contains the distance and time matrix and the Pareto-optimal refuel points for each pair of trips. The file \texttt	{solution.py} comprises a problem solution. Besides the information for vehicle duties and route choices, it contains methods to test the feasibility of the solution and to evaluate it. The methods to determine the estimated costs and the reviewed customers for the iterative approach, are contained in \texttt{iterative\_approach.py}. The file \texttt{entities.py} contains all entities, \ie trips, vehicles and refuel points. The file \texttt{taskgraph.py} provides methods to create the task graph and all kinds of partial task graphs. If further saves and loads the graphs to a file. The file \texttt{storage.py} contains methods to save instances, solutions and partial solutions to file and loads them.

\paragraph{Models and Heuristics} \parfill

The model formulations that are used in the heuristics are implemented in the modeling language Mosel which is used by FICO Xpress Optimization Suite. The mixed-integer linear programs are realized just as defined in \Cref{ch:heuristics}. The files \texttt{CMILP\_i.mos} and \texttt{CMILP\_1.mos} contain the $(\operatorname{CMILP}_i)$, the files \texttt{TMILP\_i.mos} and \texttt{TMILP\_1.mos} contain the $(\operatorname{TMILP}_i)$ for $i\geq 2$ and $i = 1$, respectively. For the iterative heuristic, the file \texttt{HSP.mos} contains the $(\operatorname{HSP}_B)$ and \texttt{MMILP\_E.mos} contains both $\eqref{eq:FMILP_max}$ and $\eqref{eq:FMILP_min}$. The models read the structure of the task graph from a \texttt{.txt} file which has been created in \texttt{taskgraph.py} and write the computed solution to another \texttt{.txt} file that is loaded by \texttt{taskgraph.py} again.

In order to restrict the running times of the heuristics, for each of these problems a maximum time is set. This means, if after this time no optimal solution for this partial instance is found, the algorithm terminates and returns the current best feasible solution. If no feasible solution is found up to then, the solver continues until he finds a feasible solution.

\paragraph{Optimal Approach} \parfill

For the realization of the optimal approach, we use the framework DIP (cf.~\cite{DIP}). This framework provides the core functions for a Dantzig-Wolfe decomposition and is implemented in C++. In order to solve the problem optimally, we customize the framework by overriding the respective methods. We create the class \texttt{SchedulingDecompApp} which is derived from the class \texttt{DecompApp}. This class is represented in the following files: \texttt{SchedulingDecompApp.h} and \texttt{SchedulingDecompApp.cpp} contain the methods for creating the task graph, defining the model, generating the initial values and the main method for solving the subproblem. The file \texttt{SchedulingDecompSolveRelaxed.h} contains the heuristic for solving the subproblem and\par
\texttt{SchedulingDecompSolveRelaxedBoost.h} solves the subproblem optimally. We further create the class \texttt{SchedulingAlgoPC} which is derived from the class \texttt{DecompAlgoPC} and contains the Branch-and-Bound procedure.

The file \texttt{module.cpp} provides the interface which is available in Python. To the method \texttt{Solve}, a problem instance and an initial solution is submitted. This is then converted into an internal representation in the files \texttt{instance.h} and \texttt{instance.cpp}. With this, the customized algorithm is executed and solves the problem to optimality. After termination, the solution is returned and saved to file.

%----------------------------------------------------------------------------------------------------------------------------------------

\section{Computational Results}
\label{sec:computational_results}

We have implemented all heuristical approaches that we have discussed in \Cref{ch:heuristics} and the optimal approach as examined in \Cref{ch:optimal_approach}. We evaluate these algorithms on different test instances. We vary different parameters in the instances as well as in the algorithms in order to appraise the solution methods in more detail. We expect the heuristics to cope with significantly larger input sizes than the optimal approach. Thus, we examine the heuristics as both initial solution for the optimal approach and solution method itself. In the former case, we choose the instance sizes such that an optimal solution can be expected in reasonable time. In the latter case, we aspire realistic instance sizes in order to estimate the behavior in a realistic environment. According to the results of the underlying theses, we expect the optimal approach to cope with about 140 trips (cf.~\cite[p.~139]{Kaiser}) and the heuristics to cope with about 2000 trips (cf.~\cite[p.~138]{Knoll}).

\paragraph{Test Instances} \parfill

For testing the heuristical solution methods, we consider instances with 100 vehicles and 500 customers. We examine three cases, the number of alternative routes per customer is restricted to 2 in the first case, restricted to 3 in the seconds case and unrestricted in the third case. For each of these cases, we create four test instances independently from each other according to \Cref{ch:instance_creation}. Thus, in average there are approximately 1800, 2300 and 3200 trips in each instance, respectively. Additionally, there are 313 refuel points in each instance. All these instances cover a time range of 24 hours and the trips are distributed over time similar to \Cref{fig:trip_distribution}. Further, we aim to test the heuristics on instances with varied customer extension. Therefore, we create a copy of each test instance, where we shift each route up to 6 hours randomly in time.

For the optimal approach, we use a test instance with
\begin{align*}
	\vert\mathcal{V}\vert = 10 && \vert\mathcal{C}\vert = 50 && \vert\mathcal{M}\vert = 150 && \vert\mathcal{T}\vert = 230 && \vert\mathcal{R}\vert = 313
\end{align*}

that covers a time range of 24 hours. Out of this test instance, we create several subinstances, this means their customer sets are subsets of the first customer set. For each instance, we create an additional instance in which 2 alternatives are selected for each customer. For computing an initial solution, we apply the time-dependent heuristic with 30 vertices per partial instance.

\paragraph{Heuristics} \parfill

As stated before, we have a total of 24 test instances. For each of these instances, we have applied the Successive Heuristic with a customer-dependent splitting and a time-dependent splitting, respectively. We have tested them with an aspired number of vertices of 100, 200 and 400 for each partial instance. All computations have been performed on a Linux-based operation system with 2.2GHz CPU and 128GB main memory.

For each execution of the heuristic, we measure the computation time. This time comprises creating the partial task graphs, solving the partial instances, determining the end points and connecting the partial solutions. It does not contain retrieving the distance and time matrix and building the task graph, from which the partial task graphs are created. We have not examined the determination of a lower bound for the optimal objective value for this problem. Therefore we cannot come up with an optimality gap for these heuristics.

Most of the heuristic applications result in feasible duties. In some cases, a partial instance is infeasible. Then, the complete heuristic cannot be completed. In order to avoid these infeasibilities, we have ensured that the number of available vehicles is sufficient for the number of customers. Nevertheless, the first partial instance $I_1$ is infeasible in several executions of the heuristic with the following reason: Let $t\in\Phat_1$ be an end point with initial fuel $f^0_t$. Due to $\eqref{eq:CMILP:fmax}$ holds ${f^0_t\leq f^{\max}_t}$ with ${f^{\max}_t = 1 - \min_{r\in\mathcal{R}}\left(\fd_{r,t}\right)}$. Because of the simplification as described in \Cref{sec:implementation}, there is only one refuel point on each arc. We call this refuel point $R(s,t)$ for ${(s,t)\in\overline{A}}$. If the initial fuel of the end point $t$ is too large, \ie ${f^0_t > 1 - \fd_{R(v,t),t}}$ for all ${v\in\mathcal{V}}$, the end point cannot be connected feasibly to any vehicle and thus $I_1$ is infeasible. In order to avoid this malfunction, we could add a suitable refuel point ${r\in\argmin_{r\in\mathcal{R}}\left(\fd_{r,t}\right)}$ to each arc ${(v,t)\in\overline{A}}$ with ${v\in\mathcal{V}}$ and ${t\in\mathcal{T}}$. However, implementing this improvement requires several modifications in the structure of the code. As the heuristic provides feasible solutions for each test instance anyway, this implementation is left open.

We have evaluated 24 test instances, where 12 of them emerge from shifting routes of the other instances. For each type of instance, \ie restricted to 2 or 3 alternatives or unrestricted, we have chosen 2 test instances each, whose total costs are on average to all evaluated instances of this type, in order to provide their results in detail. \Cref{tab:results:general} provides the results for these selected instances and shows in which components the total cost is split up. For each instance, the heuristic has been evaluated 6 times, \ie 3 different splitting sizes with customer- and time-dependent splitting each. We provide the respective best result of these evaluations \wrt the total cost. The columns 1-4 state the instances sizes, the other columns show the total cost, the number of vehicles used and the respective trip, deadhead and route cost.

\begin{table}[htb]
	\centering
	\begin{tabular}{ccccccccc}
		\toprule
		$\vert\mathcal{V}\vert$ & $\vert\mathcal{C}\vert$ & $\vert\mathcal{M}\vert$ & $\vert\mathcal{T}\vert$ & Total Cost & Duties & Trip & Deadhead & Route \\
		\midrule
		100 & 500 &  996 & 1793 & 13,149,336 & 23 & 3,063,922 & 1,626,368 & 7,309,047 \\
		100 & 500 &  997 & 1828 & 13,641,367 & 26 & 3,398,177 & 1,518,512 & 7,424,678 \\
		100 & 500 & 1486 & 2327 & 12,171,599 & 21 & 2,840,081 & 1,033,910 & 7,247,609 \\
		100 & 500 & 1491 & 2338 & 12,392,594 & 20 & 2,876,440 & 1,332,836 & 7,183,318 \\
		100 & 500 & 2335 & 3190 & 11,327,191 & 17 & 2,103,052 & 1,207,107 & 7,167,032 \\
		100 & 500 & 2354 & 3228 & 11,364,031 & 18 & 2,114,112 & 1,034,166 & 7,315,753 \\
		\bottomrule
	\end{tabular}
	\caption{Distribution of the schedule cost for several instances	}
	\label{tab:results:general}
\end{table}

We see that the total cost as well as the number of duties is considerably smaller for test instances with more alternatives per customer. We discuss the reason in \Cref{sec:interpretation}. In average, the trip cost contributes 22\%, the deadhead cost 10\%, the route cost 58\% and the vehicle cost 8\% to the total cost. The vehicle cost is only a small part of the total cost. By increasing the unit vehicle cost, we could possibly achieve solutions where less vehicles are used.

In order to examine the influence of the customer extension $L_{\operatorname{C}}$ to the heuristic in a realistic environment, we have created test instances with a large customer extension. For more comparability, these instances emerge from the original instances by just shifting the routes in time. In the original instances, the average customer extension, \ie ${\frac{1}{\vert\mathcal{C}\vert}\sum_{c\in\mathcal{C}}\left(\zend_c - \zstart_c\right)}$ is about 0:30 hours in each instance. By shifting the trips, the average customer extension grows to about 2:00 hours if each customer has at most 2 alternatives, 3:00 hours with 3 alternatives and 4:00 hours in the unrestricted case. We have evaluated all instances and the respective shifted instances with the same kind of heuristic. In summary, the total costs of the solutions are 3.1\% higher in the shifted instance. If we consider only solutions which have been created with a customer-dependent splitting, the total costs are 2.6\% higher, with a time-dependent splitting they are 3.5\% higher. These results are based on 47 pairs of feasible heuristic solutions.

\Cref{tab:results:extension} shows the results of one selected instance of each kind and its respective shifted instance. Columns 1-2 state the instance sizes, columns 3-4 the average and the maximum customer extension in hours. Columns 5-8 state the total cost and the number of duties for a customer-dependent and a time-dependent splitting. In each evaluation, the splitting size is 200 vertices per partial instance.

\begin{table}[htb]
	\centering
	\begin{tabular}{cccc cc cc}
		\toprule
		&& \multicolumn{2}{c}{Customer Extension} & \multicolumn{2}{c}{Customer-Splitting} & \multicolumn{2}{c}{Time-Splitting} \\
		\cmidrule(r){3-8}
		$\vert\mathcal{C}\vert$ & $\vert\mathcal{T}\vert$ & avg [h] & max [h] & Cost & Duties & Cost & Duties \\
		\midrule
		500 & 1793 & 0:28 & 2:38 & 13,369,843 & 24 & 13,149,336 & 23 \\
		500 & 1793 & 2:08 & 6:00 & 13,579,114 & 27 & 13,684,189 & 29 \\
		500 & 2327 & 0:32 & 1:55 & 12,445,088 & 19 & 12,385,898 & 21 \\
		500 & 2327 & 3:10 & 6:42 & 12,963,918 & 23 & 12,937,916 & 26 \\
		500 & 3190 & 0:37 & 2:22 & 11,448,625 & 17 & 11,447,670 & 16 \\
		500 & 3190 & 3:58 & 8:25 & 11,824,691 & 18 & 11,572,252 & 20 \\
		\bottomrule
	\end{tabular}
	\caption{Solution behavior with modified customer extension}
	\label{tab:results:extension}
\end{table}

In summary, both heuristics can cope with larger customer extensions. In the shifted instances, the results are slightly worse, where the customer-dependent heuristic handles the bad conditions better than the time-dependent heuristic.

Finally, we compare the heuristics \wrt their type of splitting. We evaluate all instances with a customer-dependent splitting and a time-dependent splitting and with 100, 200 and 400 vertices per partial instance. For all kinds of heuristics, we compare the total cost of the solution and the computation time of the heuristic. In summary, the total costs of the solutions that have been computed with the customer-dependent heuristic, are in average 0.9\% higher than with the time-dependent splitting. Further the computation time is 45.0\% higher. Comparing the splitting sizes, 200 vertices per partial instance provide the best results. The total costs for solutions that have been computed with 100 vertices are in average 1.9\% higher, with 400 vertices 0.8\% higher. The computation time for a splitting size of 200 is 3.18 times the computation time for splitting size 100, the computation time for splitting size 400 is 1.89 times the computation time for 200 vertices. These results are based on 29 pairs of feasible solutions for comparing the kind of heuristic and 18 triples of feasible solutions for comparing the splitting sizes.

In \Cref{tab:results:splittings}, we compare the different splittings on 3 exemplary instances, one for each kind of test instances. The instances have the following values:
\begin{align*}
	& I_1: && \vert\mathcal{V}\vert = 100 && \vert\mathcal{C}\vert = 500 && \vert\mathcal{M}\vert = 997 && \vert\mathcal{T}\vert = 1828 && 2 \text{ alternatives} \\
	& I_2: && \vert\mathcal{V}\vert = 100 && \vert\mathcal{C}\vert = 500 && \vert\mathcal{M}\vert = 1486 && \vert\mathcal{T}\vert = 2327 && 3 \text{ alternatives} \\
	& I_3: && \vert\mathcal{V}\vert = 100 && \vert\mathcal{C}\vert = 500 && \vert\mathcal{M}\vert = 2335 && \vert\mathcal{T}\vert = 3190 && \text{unrestricted}
\end{align*}

The columns 1-2 state the splitting type and the approximate number of vertices per partial instance. Columns 3-5 state the total cost of the solution in magnitude $\cdot 10^6$ for each test instance, columns 6-8 state the number of duties and columns 9-11 show the computation time in hours. In the customer-dependent heuristic with splitting size 100, applied on the test instance $I_3$, the first partial instance has been infeasible. Therefore, no heuristic solution exists.

\begin{table}[htb]
	\centering
	\begin{tabular}{lc|ccc|ccc|ccc}
		\toprule
		\multicolumn{2}{c}{Splitting} & \multicolumn{3}{c}{Total Cost $[\cdot 10^6]$} & \multicolumn{3}{c}{Duties} & \multicolumn{3}{c}{Comp. Time [h]} \\
		\cmidrule(r){3-11}
		&& $I_1$ & $I_2$ & $I_3$ & $I_1$ & $I_2$ & $I_3$ & $I_1$ & $I_2$ & $I_3$ \\
		\midrule
		customer & 100  &  13.84 & 12.83 &   -    &  26 & 21 & -   &  0:14 & 0:16 &  -   \\
		time     & 100  &  13.74 & 12.47 & 11.59  &  23 & 19 & 17  &  0:10 & 0:12 & 0:29 \\
		customer & 200  &  13.80 & 12.44 & 11.44  &  26 & 19 & 17  &  0:49 & 1:22 & 1:29 \\
		time     & 200  &  13.64 & 12.25 & 11.44  &  26 & 20 & 16  &  0:40 & 0:40 & 0:40 \\
		customer & 400  &  14.28 & 12.38 & 11.59  &  40 & 21 & 18  &  0:57 & 1:45 & 2:54 \\
		time     & 400  &  14.56 & 12.17 & 11.32  &  42 & 21 & 17  &  0:53 & 1:27 & 2:20 \\
		\bottomrule
	\end{tabular}
	\caption{Comparison of different splittings}
	\label{tab:results:splittings}
\end{table}

In summary, the time-dependent heuristic gives slightly better results than the customer-dependent heuristic and the computation time is significantly shorter. If we split the instance in smaller partial instances, the heuristic is much faster, but provides slightly worse results. If the size of the partial instances is too high, \ie 400 vertices each, then the partial instances cannot be solved to optimality in the given time window of 10 minutes. Then the partial solutions are not optimal and therefore the heuristic solution is worse. We expect to receive a better heuristic solution for splitting size 400, if we increase the maximum computation time. 

\paragraph{Iterative Heuristic} \parfill

In the iterative heuristic, the route choices are reviewed. This approach improves an existing heuristic solution. Based on the existing solution, we identify customers with potentially bad route choices and review them iteratively. This approach requires several alternative routes for the customers, thus we examine it only on the test instances with 3 alternatives and an unrestricted number of alternatives. For each, we select 2 instances for testing, thus we test 4 instances in total. For comparability, we apply the iterative heuristic always on the solution, that has been computed with the time-dependent heuristic with 200 vertices per partial instance. We fix the parameters for the customer choice according to \Cref{alg:critical_customers} as follows:
\begin{align*}
	r_{\min} \in\left\{1.5,2,3\right\} && c_{\max} = 10 && t_{\max} = 7200 && n_{\max} = 10
\end{align*}

This means, we vary only the minimal ratio for customers that are reviewed. The algorithm performs at most 10 iterations with at most 10 customers each. Thus, at most 100 customers may be reviewed. The time range for the subproblem is 2 hours, hence we can almost cover the complete instance of 24 hours in 10 iterations, if this is necessary.

Surprisingly, we do not recognize a different behavior of the iterative heuristic on the instances with restricted alternatives and the unrestricted instances. Based on the evaluations of 4 test instances, we receive the following results:
\begin{itemize}
	\item{$r_{\min} = 1.5$:}
In average, there are 77 customers whose ratio lie above the threshold. Out of these 77 reviewed customers, for 11 customers the route is changed. The objective value improves by 1.3\% and the computation time is about 1:00 hour for the iterative heuristic without computing the initial solution.
	\item{$r_{\min} = 2$:}
In average, 23 customers are reviewed and the route is changed for 4 of them. The total cost is decreased by 1.0\% and the computation time is about 0:30 hours.
	\item{$r_{\min} = 3$:}
In average, from 5 reviewed customers the route is changed for 1 customer. The total cost improves by 0.2\% and the computation time is 0:15 hours in average. In contrast to the other evaluations, the restriction for the number of iterations is not exceeded here.
\end{itemize}

In the majority of iterations, there is no customer whose route is changed. Thus, the total trip and route costs do not change either. Nevertheless, the total cost decreases in most of the iterations. Thus, the deadhead cost or the vehicle cost decreases. This means that the Iterative Heuristic improves not only the route choices, but also the assignment of trips to vehicles and the visitation of refuel points.

Finally, we provide the evaluation results for one exemplary instance with ${\vert\mathcal{V}\vert=499}$ and ${\vert\mathcal{V}\vert=2338}$. The total cost of the initial solution amounts 12,392,594 with 20 duties. \Cref{tab:results:iterative} states the results for 3 evaluations with different values for $r_{\min}$. The columns provide the total cost of the iterative solution, the number of vehicles used, the number of reviewed customers, the number of customers with changed route decisions and the total computation time for the evaluation.

\begin{table}[htb]
	\centering
	\begin{tabular}{ccc c cc}
		\toprule
		$r_{\min}$ & Total Cost & Duties & \parbox[c]{2cm}{\centering Reviewed \\ Customers} & \parbox[c]{2cm}{\centering Adjusted \\ Customers} & \parbox{1.5cm}{\centering Comp. \\ Time [h]} \\
		\midrule
		1.5 & 12,180,474 & 22 & 85 & 13 & 1:01 \\
		2   & 12,277,797 & 20 & 25 & 5  & 0:30 \\
		3   & 12,382,980 & 20 & 4  & 0  & 0:07 \\
		\bottomrule
	\end{tabular}
	\caption{Test results for the iterative heuristic}
	\label{tab:results:iterative}
\end{table}

It is remarkable that the number of duties increases in the first evaluation. At the same time, the deadhead cost decreases from 1,332,836 to 1,119,303.

\paragraph{Optimal Approach} \parfill

We examine the optimal approach with an initial solution that has been computed with a time-dependent heuristic. Instead of just one possible refuel point in each arc, we consider a set of Pareto-optimal refuel points. This heavily increases the number of feasible duties and therefore the computation time. A great issue in the optimal approach is solving the subproblem, \ie finding feasible vehicle duties with negative reduced cost. For this, we create a SPPRC with the resources reduced cost, fuel, duty length and routes. The number of labels in \Cref{alg:label_setting} grows exponentially with the number of resources. As there is one resource for each route ${m\in\mathcal{M}}$, we expect a considerably increased computation time by the route resources. Thus, we examine whether including the route resources yields a better behavior of the algorithm. All computations have been performed on a notebook with Intel Core i5-6200U 2.3GHz CPU and 8GB main memory that runs on a Microsoft Windows 10 operation system.

First, we apply the optimal approach without including the route resources. \Cref{tab:results:optimal} provides the computational results for the sequence of test instances. The test instances in the first part have 2 alternatives per customer, in the second part 3 alternatives each. The maximum computation time is set to 30 minutes. After reaching the time limit, the algorithm returns the current best solution. The columns show the number of customers and trips in the test instance, the total cost of the initial solution and the optimal solution and the number of duties in the optimal solution. Further the gap between the initial solution and the optimal solution, the number of nodes in the Branch-and-Bound process and the computation time in minutes is shown.

\begin{table}[htb]
	\centering
	\begin{tabular}{cccccccc}
		\toprule
		$\vert\mathcal{C}\vert$ & $\vert\mathcal{T}\vert$ & Initial Cost & Optimal Cost & Duties & Gap & Nodes & \parbox[c]{2cm}{\centering Comp. \\ Time [min]} \\
		\midrule
		10 & 32 & 284,281 & 284,202 & 1 & 0.03\% & 1 & 0:02 \\
		15 & 47 & 417,268 & 417,034 & 2 & 0.06\% & 1 & 0:04 \\
		20 & 61 & 602,907 & 602,889 & 2 & 0.00\% & 1 & 0:33 \\
		25 & 79 & 776,536 & 773,129 & 2 & 0.44\% & 3 & 4:33 \\
		30 & 92 & 826,880 & 826,358 & 3 & 0.06\% & 5 & 30:00 \\
		\midrule
		10 & 47 & 279,419 & 278,795 & 1 & 0.22\% & 1 & 0:11 \\
		15 & 69 & 404,437 & 403,174 & 2 & 0.31\% & 3 & 30:00 \\
		\bottomrule
	\end{tabular}
	\caption{Test results for the optimal approach}
	\label{tab:results:optimal}
\end{table}
		
For the respective last instances with ${\vert\mathcal{T}\vert=92}$ and ${\vert\mathcal{T}\vert=69}$, the algorithm has not found an optimal solution when reaching the time limit. There, the current best solution and the number of nodes that have been created so far is shown. It is noteworthy that the computation time of the largest solvable instances is still far away from the time limit. While the instance with ${\vert\mathcal{T}\vert=79}$ is solved to optimality in less than 5 minutes, the instance with ${\vert\mathcal{T}\vert=92}$ cannot be solved in 30 minutes. Further, in each evaluation the number of duties is equal and the route choice is not changed for any customer in comparison to the initial solution. Only the deadhead cost is decreased during the algorithm.

As stated before, including the route resources results in a significantly larger number of labels and thus solving the subproblem requires more computation time. The benefit is that the column generation process does not add duties that solely violate the cover constraints. For the decision whether the route resources are used, this benefit has to be balanced against the enlarged computation time. We have evaluated the test instances with using the route resources. With this, no solution was computed in the given time limit. What is more, in the larger instances the algorithm stopped earlier as the available main memory was not sufficient.

As the optimal approach is only an enhancement of the already existing approach, we do not evaluate this approach in more detail. For a more extensive examination, particularly with test instances on smaller time windows and an analysis of the column generation and the Branch-and-Bound process, we refer to \cite[Sec.~10.2]{Kaiser}. 

%----------------------------------------------------------------------------------------------------------------------------------------

\section{Interpretation of the Results}
\label{sec:interpretation}

Finally, we link the computational results as provided in \Cref{sec:computational_results} with the application. Based on the information of Car2Go, on current day there are 155 electrically-powered vehicles in Stuttgart. They can be recharged at 313 stations. (cf.~\cite[p.~144]{Kaiser}) Of course, these vehicles do not drive autonomously. According to \Cref{fig:trip_distribution}, there are approximately 700 rentals per day on average. Each of these rentals stands for one customer in our problem setting. For each customer, we compute alternative routes whose start and finish positions and times are similar to the original rental. An alternative may comprise more than one car trip, \ie the customers uses a vehicle before and after public transport. We have created the sets $\mathcal{C}$, $\mathcal{M}$ and $\mathcal{T}$ based on these considerations.

In order to simulate a realistic problem sizes, we created a test instance with 150 vehicles, 698 customer and an unrestricted number of alternatives per customer. This instance consists of 3201 multimodal routes with 4355 trips. We solve this instance with the time-dependent heuristic and about 400 vertices per partial instance. In order to receive good results, we increase the maximal computation time per partial instance to 30 minutes. We receive a solution with 22 duties and a total cost of 15,498,352.

In \Cref{tab:results:realistic} we see the distribution of the total costs and an evaluation of the times. In the first part, the trip, deadhead and route cost is presented with the magnitude ${\cdot 10^3}$. In the second part is listed how much time the vehicles spend for which activity. The trip time and deadhead time is the time that a vehicle is actually driving. The waiting time states the time that a vehicle waits between two trips without driving and at a refuel point when it is already fully charged. The time before the first trip and after the last trip are not included in the waiting time. The columns state the total cost and time, the average per duty and the average per customer. 

\begin{table}[htb]
	\centering
	\begin{tabular}{l|rrc}
		\toprule
		& Total  & per Duty & per Customer \\
		\midrule
		Trip Cost     &  3,019 & 137.2 &  4.3 \\
		Deadhead Cost &  1,125 &  51.1 &  1.6 \\
		Route Cost    & 10,254 & 466.1 & 14.7 \\
		\midrule
		Trip Time      &  70:44 & 5:56 & 0:11 \\
		Deadhead Time  &  25:20 & 1:09 & 0:02 \\
		Waiting Time   & 220:24 & 9:56 & 0:18 \\
		Refueling Time &  91:01 & 4:08 & 0:07 \\
		\bottomrule
	\end{tabular}
	\caption{Cost distribution for a realistic instance in magnitude $\cdot 10^3$ and [h]}
	\label{tab:results:realistic}
\end{table}

The heuristic solution contains 22 duties, \ie we need 22 autonomous vehicles in order to satisfy 700 customers. This is one-seventh of the available fleet. We see that the vehicles cover 3000km carrying customers and 1100km for driving to the customers and refuel points. Each used vehicle covers in average 188km in 24 hours. According to the considerations in \Cref{sec:fuel_cost}, the average route costs are 7.30 euros per customer. This stands for the user inconvenience, \ie a real cost for using public transport and an imaginary cost for spending time. A penalty cost of 50,000 occurs for each used vehicle, this means the cost for using an additional vehicle corresponds to a detour of 50km.

Considering the time, each vehicle spends in average 6 hours for carrying customers and 1 hour for deadhead trips. Further it is recharged for 4 hours. The waiting time amounts 10 hours. We can see that the vehicles are not working to capacity. However, during the peak there are more than 60 trips per hour. Thus, the majority of vehicles is needed to cover the trips at the peak. During the periods with less demand, the vehicles are idle. As we do not require the vehicles to be recharged after usage, the recharging time is only 4 hours. The range of a vehicle is 135km, with 4 hours of recharging it increases to about 205km. This is only a little more than the actually covered distance of 188km.

We can see that instances, where more alternatives are available, result in significantly better solutions. This behavior is caused by two reasons: On the one hand, each solution in an instance with fewer alternatives is also a feasible solution in an instance with more alternatives, but not vice versa. This obviously leads to a better solution for the instance with more alternatives. On the other hand, while creating the instances, we prefer routes with two car trips to routes with only one car trip. We do this in order to include all facets of the problem setting in a relatively small instance. However, routes with two trips are not very profitable in general due to the restricted ability of the OTP. The later included alternatives are more profitable and thus the solution is better for instances with more alternatives.

\paragraph{Comparison to the Underlying Theses} \parfill

Finally, we compare our computational results to the respective results of the underlying theses. \cite[pp.~135-136]{Knoll} have evaluated the Successive Heuristic for the simplified problem setting without cover constraints. They used realistic instances as shown in \Cref{tab:results:knoll}. It states the number of vehicles and trips, the number of partial instances, the optimality gap and the computation time in hours. The optimality gap has been computed with relaxing the fuel constraints.

\begin{table}[htb]
	\centering
	\begin{tabular}{ccccc}
		\toprule
		$\vert\mathcal{V}\vert$ & $\vert\mathcal{T}\vert$ & \parbox[c]{2cm}{\centering Partial \\ Instances} & Gap & \parbox[c]{2cm}{\centering Comp. \\ Time [h]} \\
		\midrule
		387 & 1836 & 7 & 7.30\% & 0:54 \\
		423 & 2031 & 6 & 2.63\% & 1:16 \\
		450 & 2400 & 7 & 9.61\% &  -   \\
		\bottomrule
	\end{tabular}
	\caption{Summarized results of \cite[Tables~10.3,~10.4,~10.5]{Knoll}}
	\label{tab:results:knoll}
\end{table}

The time limit for solving the partial instances was 900 seconds. For the last instance, no computation time is given. In summary, the computation times as stated in \Cref{tab:results:splittings} and \Cref{tab:results:knoll} are similar for the same number of trips and the same size of the partial instances. The only difference in both models are the cover constraints. In the simplified problem setting each trip is fulfilled, while all customers have to be satisfied in our model. This means that the partial duties contain less trips in our model if the number of vertices in both settings is the same. Apparently, this difference does not cause a huge change in the behavior of the heuristic. In contrast to the problem setting without cover constraints, we cannot determine a lower bound with relaxing the fuel constraints. According to \Cref{th:complexity_VSPMC}, our problem is still $\mathcal{NP}$-hard then. 

\cite[pp.~137-140]{Kaiser} have evaluated the Optimal Approach for the simplified problem setting with single-leg cover constraints. In \Cref{tab:results:kaiser}, we compare the respective largest instances that could be solved to optimality in the time limit of 30 minutes. The upper section shows the previous results for single-leg cover constraints and the lower section shows the results for the multi-leg cover constraints. The columns show the number of customers, the number of trips, the number of trips per customer, the number of nodes of the Branch-and-Bound tree and the computation time in minutes. The computation conditions of both evaluations are similar.

\begin{table}[htb]
	\centering
	\begin{tabular}{cccccccc}
		\toprule
		$\vert\mathcal{C}\vert$ & $\vert\mathcal{T}\vert$ & $\vert\mathcal{T}\vert/\vert\mathcal{C}\vert$ & Nodes & \parbox[c]{2cm}{\centering Comp. \\ Time [min]} \\
		\midrule
		50 & 114 & 2.3 & 1 & 9:02 \\
		60 & 138 & 2.3 & 1 & 22:02 \\
		\midrule
		25 & 79 & 3.2 & 3 & 4:33 \\
		10 & 47 & 4.7 & 1 & 0:11 \\
		\bottomrule
	\end{tabular}
	\caption{Summarized results of \cite[Table~10.4]{Kaiser} and \Cref{tab:results:optimal}}
	\label{tab:results:kaiser}
\end{table}

We see that the previous algorithm is able to cope with a far larger number of trips. Possibly, this is caused by an increased number of alternative trips per customer. The previous algorithm can solve instances with more trips, while the number of trips per customer is significantly lower than in our setting. This assumption is confirmed by the fact that our algorithm is able to solve an instance with 79 trips and 25 customers, but not a similar instance wit 69 trips and 15 customers.